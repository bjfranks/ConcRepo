% !TeX root = root.tex
% !TeX spellcheck = en_US
\section{Correctness of the Determinization Construction}
We show that $w \in L(D) \Rightarrow w \in L(N)$, where $D$ is the DFA constructed from the NFA $N$.

Let $w \in L(D)$ be an arbitrary word in the accepted language of $D$. With definition of $L(D)$ there is an accepting run $r_D = r_0^D \dots r_n^D$ of $D$ for $w$. We show by induction that there is also an accepting run $r_0^N \dots r_n^N$ of $N$ for $w$. To simplify notations, we say that a walk is a run that does not have to start with an initial state.

\begin{description}
\item[Base case:] For $i=0$ we have $w_{n-i+1} \dots w_n = \epsilon$. Since the run $r_D$ is accepting, it holds that $r_n^D \cap F_N \neq \emptyset$. Therefore, there exists a state $r_n^N \in r_n^D \cap F_N$ that gives us an accepting walk of $N$ for the empty word $\epsilon$ with $r_n^N \in r_n^D$.
\item[Inductive hypothesis:] For $0 \leq i \leq n$ there is an accepting walk $r_{n-i}^N \dots r_n^N$ of $N$ for $w_{n-i+1} \dots w_n$ with $r_{n-i}^N \in r_{n-i}^D$.
\item[Inductive step:] $i \rightarrow i+1$\\
With the inductive hypothesis there is a walk $r_{n-i}^N \dots r_n^N$ with $r_n^N \in F_N$ for $w_{n-i+1} \dots w_n$. By construction of $D$ there exists a state $r_{n-(i+1)}^N \in r_{n-(i+1)}^D$ such that $r_{n-i}^N \in \delta_N(r_{n-(i+1)}^N, w_{n-i})$. Thus, $r_{n-(i+1)}^N r_{n-i}^N \dots r_n^N$ is an accepting walk of $N$ for $w_{n-i} \dots w_n$ with $r_{n-(i+1)}^N \in r_{n-(i+1)}^D$.
\end{description}

Since $r_{n-n}^D = r_0^D = \{q_0^N\}$, it holds that $r_0^N \dots r_n^N$ is an accepting run of $N$ for $w$.

\section{Encoding Programs as Automaton}
\textbf{Task 1.} 
The following automata shows the example of a semaphore program for $P=3$ simultaneous programs and $n=2$ acquire permits.
\begin{figure}[h]
\begin{tikzpicture}[auto,swap]
    \foreach \pos/\name in {{(0,2)/000}, {(0,0)/100}, {(3,0)/110},{(6,0)/111},{(0,-2)/200},{(3,-2)/210},{(6,-2)/220},{(6,-2)/211},{(9,-2)/221},{(12,-2)/222},{(6,-4)/311},{(9,-4)/321},{(12,-4)/322},{(3,-4)/220},{(9,-6)/331},{(12,-6)/332},{(12,-8)/333}}
        \node[vertex] (\name) at \pos {$\name$};
    \foreach \source/ \dest /\weight in {000/100/acquire(), 100/200/acquire(),100/110/balance+=x;,200/210/balance+=x;,110/111/release(),210/211/release();,111/211/acquire(),211/311/acquire();,211/221/balance+=x;,221/222/release(),221/321/acquire(),321/322/release(),222/322/acquire(),311/321/balance+=x;,110/210/acquire(),210/220/balance+=x;,220/221/release(),321/331/balance+=x;,331/332/release(),332/333/release(),322/332/balance+=x;}
        \path[edge] (\source) -- node[weight] {$\weight$} (\dest);
\end{tikzpicture}
\end{figure}
\\
\textbf{Task 2.} According to the task a thread can use lock() an arbitrary amount of times. This makes the state space infinte and therefor the reentrant lock cannot be represented by an NFA. If there is a maximum amount $n$ of times lock() can be used the automaton will look like $n$ merged lock automatons.
